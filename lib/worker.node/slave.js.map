{"version":3,"sources":["worker.node/slave.js"],"names":["vm","require","errorCatcherInPlace","messageHandler","console","error","setupErrorCatcher","process","on","messageHandlerError","runAsSandboxedModule","code","sandbox","Buffer","clearInterval","clearTimeout","module","exports","setInterval","setTimeout","runInNewContext","messageHandlerDone","args","send","response","transfer","pop","messageHandlerProgress","progress","message","stack","isPromise","thing","then","data","initByScript","script","initByMethod","method","doRun","returned","param","result"],"mappings":";;AAAA;AACA;AACA,IAAMA,KAAKC,QAAQ,IAAR,CAAX;;AAEA,IAAIC,sBAAsB,KAA1B;AACA,IAAIC,iBAAiB,0BAAW;AAC9BC,UAAQC,KAAR,CAAc,8BAAd,EAD8B,CACoB;AACnD,CAFD;;AAIA,SAASC,iBAAT,GAA6B;AAC3B,MAAIJ,mBAAJ,EAAyB;AAAE;AAAS;;AAEpCK,UAAQC,EAAR,CAAW,mBAAX,EAAgCC,mBAAhC;AACAF,UAAQC,EAAR,CAAW,oBAAX,EAAiCC,mBAAjC;;AAEAP,wBAAsB,IAAtB;AACD;;AAGD,SAASQ,oBAAT,CAA8BC,IAA9B,EAAoC;AAClC,MAAIC,UAAU;AACZC,kBADY;AAEZT,oBAFY;AAGZU,gCAHY;AAIZC,8BAJY;AAKZC,YAAgB,EAAEC,SAAU,IAAZ,EALJ;AAMZhB,oBANY;AAOZiB,4BAPY;AAQZC;AARY,GAAd;;AAWAnB,KAAGoB,eAAH,CAAmBT,IAAnB,EAAyBC,OAAzB;AACA,SAAOA,QAAQI,MAAR,CAAeC,OAAtB;AACD;;AAGD,SAASI,kBAAT,GAAqC;AAAA,oCAANC,IAAM;AAANA,QAAM;AAAA;;AACnCf,UAAQgB,IAAR,CAAa,EAAEC,UAAUF,IAAZ,EAAb;AACD;;AAEDD,mBAAmBI,QAAnB,GAA8B,YAAkB;AAAA,qCAANH,IAAM;AAANA,QAAM;AAAA;;AAC9CA,OAAKI,GAAL,GAD8C,CAC1B;AACpBL,sCAAsBC,IAAtB;AACD,CAHD;;AAKA,SAASK,sBAAT,CAAgCC,QAAhC,EAA0C;AACxCrB,UAAQgB,IAAR,CAAa,EAAEK,kBAAF,EAAb;AACD;;AAED,SAASnB,mBAAT,CAA6BJ,KAA7B,EAAoC;AAClCE,UAAQgB,IAAR,CAAa;AACXlB,WAAQ,EAAEwB,SAAUxB,MAAMwB,OAAlB,EAA2BC,OAAQzB,MAAMyB,KAAzC;AADG,GAAb;AAGD;;AAED,SAASC,SAAT,CAAoBC,KAApB,EAA2B;AACzB,SAAOA,SAAS,OAAOA,MAAMC,IAAb,KAAsB,UAAtC;AACD;;AAED1B,QAAQC,EAAR,CAAW,SAAX,EAAsB,UAAS0B,IAAT,EAAe;AACnC,MAAIA,KAAKC,YAAT,EAAuB;AACrBhC,qBAAiBF,QAAQiC,KAAKE,MAAb,CAAjB;AACD;;AAED,MAAIF,KAAKG,YAAT,EAAuB;AACrBlC,qBAAiBO,qBAAqB,sBAAsBwB,KAAKI,MAAhD,CAAjB;AACD;;AAED,MAAIJ,KAAKK,KAAT,EAAgB;AACd;AACA;AACAjC;;AAEA,QAAMkC,WAAWrC,eAAe+B,KAAKO,KAApB,EAA2BpB,kBAA3B,EAA+CM,sBAA/C,CAAjB;;AAEA,QAAII,UAAUS,QAAV,CAAJ,EAAyB;AACvBA,eAASP,IAAT,CACE,UAACS,MAAD;AAAA,eAAYrB,mBAAmBqB,MAAnB,CAAZ;AAAA,OADF,EAEE,UAACrC,KAAD;AAAA,eAAWI,oBAAoBJ,KAApB,CAAX;AAAA,OAFF;AAID;AACF;AACF,CAvBD","file":"slave.js","sourcesContent":["// not using ES6 import/export syntax, since we need to require() in a handler\r\n// what the ES6 syntax does not permit\r\nconst vm = require('vm');\r\n\r\nlet errorCatcherInPlace = false;\r\nlet messageHandler = function() {\r\n  console.error('No thread logic initialized.');    // eslint-disable-line no-console\r\n};\r\n\r\nfunction setupErrorCatcher() {\r\n  if (errorCatcherInPlace) { return; }\r\n\r\n  process.on('uncaughtException', messageHandlerError);\r\n  process.on('unhandledRejection', messageHandlerError);\r\n\r\n  errorCatcherInPlace = true;\r\n}\r\n\r\n\r\nfunction runAsSandboxedModule(code) {\r\n  var sandbox = {\r\n    Buffer,\r\n    console,\r\n    clearInterval,\r\n    clearTimeout,\r\n    module        : { exports : null },\r\n    require,\r\n    setInterval,\r\n    setTimeout\r\n  };\r\n\r\n  vm.runInNewContext(code, sandbox);\r\n  return sandbox.module.exports;\r\n}\r\n\r\n\r\nfunction messageHandlerDone(...args) {\r\n  process.send({ response: args });\r\n}\r\n\r\nmessageHandlerDone.transfer = function(...args) {\r\n  args.pop();         // ignore last parameter, since it's only useful for browser code\r\n  messageHandlerDone(...args);\r\n};\r\n\r\nfunction messageHandlerProgress(progress) {\r\n  process.send({ progress });\r\n}\r\n\r\nfunction messageHandlerError(error) {\r\n  process.send({\r\n    error : { message : error.message, stack : error.stack }\r\n  });\r\n}\r\n\r\nfunction isPromise (thing) {\r\n  return thing && typeof thing.then === 'function';\r\n}\r\n\r\nprocess.on('message', function(data) {\r\n  if (data.initByScript) {\r\n    messageHandler = require(data.script);\r\n  }\r\n\r\n  if (data.initByMethod) {\r\n    messageHandler = runAsSandboxedModule('module.exports = ' + data.method);\r\n  }\r\n\r\n  if (data.doRun) {\r\n    // it's a good idea to wait until first thread logic run to set this up,\r\n    // so initialization errors will be printed to console\r\n    setupErrorCatcher();\r\n\r\n    const returned = messageHandler(data.param, messageHandlerDone, messageHandlerProgress);\r\n\r\n    if (isPromise(returned)) {\r\n      returned.then(\r\n        (result) => messageHandlerDone(result),\r\n        (error) => messageHandlerError(error)\r\n      );\r\n    }\r\n  }\r\n});\r\n"]}
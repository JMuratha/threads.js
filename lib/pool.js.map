{"version":3,"sources":["pool.js"],"names":["Pool","threads","options","spawn","defaults","pool","size","idleThreads","slice","jobQueue","runArgs","spawnOptions","on","job","handleNewJob","dequeue","run","args","send","Error","Job","killAll","forEach","thread","kill","queueJob","once","dropJob","push","index","indexOf","splice","length","shift","removeAllListeners","handleJobSuccess","handleJobError","handleJobAbort","executeOn","responseArgs","emit","handleJobDone","error","destroy","setTimeout","newThread","EventEmitter","threadCount","threadIndex"],"mappings":"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","file":"pool.js","sourcesContent":["import EventEmitter from 'eventemitter3';\r\nimport Job          from './job';\r\nimport defaults     from './defaults';\r\nimport { spawn }    from './';\r\n\r\nexport default class Pool extends EventEmitter {\r\n  constructor(threads, options = {}) {\r\n    super();\r\n    this.threads = Pool.spawn(threads || defaults.pool.size, options);\r\n    this.idleThreads = this.threads.slice();\r\n    this.jobQueue = [];\r\n    this.runArgs = [];\r\n    this.spawnOptions = options;\r\n\r\n    this.on('newJob', (job) => this.handleNewJob(job));\r\n    this.on('threadAvailable', () => this.dequeue());\r\n  }\r\n\r\n  run(...args) {\r\n    this.runArgs = args;\r\n    return this;\r\n  }\r\n\r\n  send(...args) {\r\n    if (!this.runArgs) {\r\n      throw new Error('Pool.send() called without prior Pool.run(). You need to define what to run first.');\r\n    }\r\n\r\n    const job = new Job(this);\r\n    return job.run(...this.runArgs).send(...args);\r\n  }\r\n\r\n  killAll() {\r\n    this.threads.forEach(thread => {\r\n      thread.kill();\r\n    });\r\n  }\r\n\r\n  queueJob(job) {\r\n    job.once('abort', () => this.dropJob(job));  // triggered by job.abort()\r\n    this.jobQueue.push(job);\r\n    this.dequeue();\r\n  }\r\n\r\n  dropJob(job) {\r\n    const index = this.jobQueue.indexOf(job);\r\n    if (index !== -1) {\r\n      this.jobQueue.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  dequeue() {\r\n    if (this.jobQueue.length === 0 || this.idleThreads.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const job = this.jobQueue.shift();\r\n    const thread = this.idleThreads.shift();\r\n\r\n    job.removeAllListeners('abort'); // remove previous listener\r\n\r\n    job\r\n      .once('done', (...args) => this.handleJobSuccess(thread, job, ...args))\r\n      .once('error', (...args) => this.handleJobError(thread, job, ...args))\r\n      .once('abort', () => this.handleJobAbort(thread, job));\r\n\r\n    job.executeOn(thread);\r\n  }\r\n\r\n  handleNewJob(job) {\r\n    job.once('readyToRun', () => this.queueJob(job));    // triggered by job.send()\r\n  }\r\n\r\n  handleJobSuccess(thread, job, ...responseArgs) {\r\n    this.emit('done', job, ...responseArgs);\r\n    this.handleJobDone(thread, job);\r\n  }\r\n\r\n  handleJobError(thread, job, error) {\r\n    this.emit('error', job, error);\r\n    this.handleJobDone(thread, job);\r\n  }\r\n\r\n  handleJobDone(thread, job) {\r\n    job.destroy();                    // to prevent memory leak\r\n    this.idleThreads.push(thread);\r\n    this.emit('threadAvailable');\r\n\r\n    if (this.idleThreads.length === this.threads.length) {\r\n      // run deferred to give other job.on('done') handlers time to run first\r\n      setTimeout(() => { this.emit('finished'); }, 0);\r\n    }\r\n  }\r\n\r\n  handleJobAbort(thread, job) {\r\n    thread.kill();\r\n\r\n    const index = this.threads.indexOf(thread);\r\n    const newThread = spawn(null, [], this.spawnOptions);\r\n\r\n    this.threads.splice(index, 1, newThread);\r\n    this.handleJobDone(newThread, job);\r\n  }\r\n}\r\n\r\nPool.spawn = (threadCount, options) => {\r\n  const threads = [];\r\n\r\n  for (let threadIndex = 0; threadIndex < threadCount; threadIndex++) {\r\n    threads.push(spawn(null, [], options));\r\n  }\r\n\r\n  return threads;\r\n};\r\n"]}